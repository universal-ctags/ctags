/*
 *
 *  Copyright (c) 2015, Red Hat, Inc.
 *  Copyright (c) 2015, Masatake YAMATO
 *
 *  Author: Masatake YAMATO <yamato@redhat.com>
 *
 *   This source code is released for free distribution under the terms of the
 *   GNU General Public License version 2 or (at your option) any later version.
 *
 */

#include "general.h"  /* must always come first */
#include "debug.h"
#include "main.h"
#include "options.h"
#include "routines.h"
#include "xtag.h"

#include <string.h>
#include <ctype.h>

typedef struct sXtagDesc {
	xtagSpec *spec;
	langType language;
	xtagType sibling;
} xtagDesc;

static bool isPseudoTagsEnabled (xtagSpec *pspec CTAGS_ATTR_UNUSED)
{
	return ! isDestinationStdout ();
}

static xtagSpec xtagSpecs [] = {
	{ true, 'F',  "fileScope",
	  "Include tags of file scope" },
	{ false, 'f', "inputFile",
	  "Include an entry for the base file name of every input file"},
	{ false, 'p', "pseudo",
	  "Include pseudo tags",
	  isPseudoTagsEnabled},
	{ false, 'q', "qualified",
	  "Include an extra class-qualified tag entry for each tag"},
	{ false, 'r', "reference",
	  "Include reference tags"},
	{ false, 'g', "guest",
	  "Include tags generated by guest parsers"},
};

static unsigned int       xtagDescUsed;
static unsigned int       xtagDescAllocated;
static xtagDesc* xtagDescs;

static xtagDesc* getXtagDesc (xtagType type)
{
	Assert ((0 <= type) && (type < xtagDescUsed));
	return (xtagDescs + type);
}

extern xtagSpec* getXtagSpec (xtagType type)
{
	Assert ((0 <= type) && (type < xtagDescUsed));

	return getXtagDesc (type)->spec;
}

typedef bool (* xtagPredicate) (xtagDesc *pdesc, langType language, const void *user_data);
static xtagType  getXtagTypeGeneric (xtagPredicate predicate, langType language, const void *user_data)
{
	static bool initialized = false;
	int i;

	if (language == LANG_AUTO && (initialized == false))
	{
		initialized = true;
		initializeParser (LANG_AUTO);
	}
	else if (language != LANG_IGNORE && (initialized == false))
		initializeParser (language);

	for (i = 0; i < xtagDescUsed; i++)
	{
		if (predicate (xtagDescs + i, language, user_data))
			return i;
	}
	return XTAG_UNKNOWN;
}

static bool xtagEqualByLetter (xtagDesc *pdesc, langType language CTAGS_ATTR_UNUSED,
							   const void *user_data)
{
	return (pdesc->spec->letter == *((char *)user_data))? true: false;
}

extern xtagType  getXtagTypeForLetter (char letter)
{
	return getXtagTypeGeneric (xtagEqualByLetter, LANG_IGNORE, &letter);
}

static bool xtagEqualByNameAndLanguage (xtagDesc *pdesc, langType language, const void *user_data)
{
	const char* name = user_data;

	if ((language == LANG_AUTO || pdesc->language == language)
		&& (strcmp (pdesc->spec->name, name) == 0))
		return true;
	else
		return false;
}

extern xtagType  getXtagTypeForNameAndLanguage (const char *name, langType language)
{
	return getXtagTypeGeneric (xtagEqualByNameAndLanguage, language, name);
}


#define PR_XTAG_WIDTH_LETTER     7
#define PR_XTAG_WIDTH_NAME      22
#define PR_XTAG_WIDTH_ENABLED   7
#define PR_XTAG_WIDTH_LANGUAGE  16
#define PR_XTAG_WIDTH_DESC      30

#define PR_XTAG_STR(X) PR_XTAG_WIDTH_##X
#define PR_XTAG_FMT(X,T) "%-" STRINGIFY(PR_XTAG_STR(X)) STRINGIFY(T)
#define MAKE_XTAG_FMT(LETTER_SPEC)		\
	PR_XTAG_FMT (LETTER,LETTER_SPEC)	\
	" "					\
	PR_XTAG_FMT (NAME,s)			\
	" "					\
	PR_XTAG_FMT (ENABLED,s)			\
	" "					\
	PR_XTAG_FMT (LANGUAGE,s)		\
	" "					\
	PR_XTAG_FMT (DESC,s)			\
	"\n"

static void printXtag (xtagType i)
{
	unsigned char letter = getXtagSpec (i)->letter;
	langType lang;
	const char *language;
	const char *desc;

	if (letter == NUL_XTAG_LETTER)
		letter = '-';


	lang = getXtagDesc (i)->language;

	if (lang == LANG_IGNORE)
		language = "NONE";
	else
		language = getLanguageName (lang);

	desc = getXtagSpec (i)->description;
	if (!desc)
		desc = "NONE";

	printf((Option.machinable? "%c\t%s\t%s\t%s\t%s\n": MAKE_XTAG_FMT(c)),
	       letter,
		   getXtagName (i),
	       getXtagSpec (i)->enabled? "TRUE": "FALSE",
		   language,
	       desc);
}

extern void printXtags (int language)
{
	unsigned int i;

	if (Option.withListHeader)
		printf ((Option.machinable? "%s\t%s\t%s\t%s\t%s\n": MAKE_XTAG_FMT(s)),
				"#LETTER", "NAME", "ENABLED", "LANGUAGE", "DESCRIPTION");

	for (i = 0; i < xtagDescUsed; i++)
	{
		if (language == LANG_AUTO || getXtagOwner (i) == language)
			printXtag (i);
	}

}

extern bool isXtagEnabled (xtagType type)
{
	xtagSpec* spec = getXtagSpec (type);

	Assert (spec);

	if (spec->isEnabled)
		return spec->isEnabled (spec);
	else
		return spec->enabled;
}

extern bool enableXtag (xtagType type, bool state)
{
	bool old;
	xtagSpec* spec = getXtagSpec (type);

	Assert (spec);

	old = isXtagEnabled (type);
	spec->enabled = state;
	spec->isEnabled = NULL;

	return old;
}

extern bool isCommonXtag (xtagType type)
{
	return (type < XTAG_COUNT)? true: false;
}

extern int     getXtagOwner (xtagType type)
{
	return getXtagDesc (type)->language;
}

const char* getXtagName (xtagType type)
{
	xtagSpec* spec = getXtagSpec (type);
	if (spec)
		return spec->name;
	else
		return NULL;
}

extern void initXtagDescs (void)
{
	xtagDesc *xdesc;

	xtagDescAllocated = ARRAY_SIZE (xtagSpecs);
	xtagDescs = xMalloc (xtagDescAllocated, xtagDesc);

	for (int i = 0; i < ARRAY_SIZE (xtagSpecs); i++)
	{
		xdesc = xtagDescs + i;
		xdesc->spec = xtagSpecs + i;
		xdesc->language = LANG_IGNORE;
		xdesc->sibling = XTAG_UNKNOWN;
		xtagDescUsed++;
	}
}

extern int countXtags (void)
{
	return xtagDescUsed;
}

static void updateSiblingXtag (xtagType type, const char* name)
{
	int i;
	xtagDesc *xdesc;

	for (i = type; i > 0; i--)
	{
		xdesc = xtagDescs + i - 1;
		if (xdesc->spec->name && (strcmp (xdesc->spec->name, name) == 0))
		{
			Assert (xdesc->sibling == XTAG_UNKNOWN);
			xdesc->sibling = type;
			break;
		}
	}
}

extern int defineXtag (xtagSpec *spec, langType language)
{
	xtagDesc *xdesc;
	size_t i;

	Assert (spec);
	Assert (spec->name);
	for (i = 0; i < strlen (spec->name); i++)
	{
		Assert ( isalnum (spec->name [i]) );
	}
	spec->letter = NUL_XTAG_LETTER;

	if (xtagDescUsed == xtagDescAllocated)
	{
		xtagDescAllocated *= 2;
		xtagDescs = xRealloc (xtagDescs, xtagDescAllocated, xtagDesc);
	}
	xdesc = xtagDescs + (xtagDescUsed);
	spec->xtype = xtagDescUsed++;
	xdesc->spec = spec;
	xdesc->language = language;
	xdesc->sibling  = XTAG_UNKNOWN;

	updateSiblingXtag (spec->xtype, spec->name);
	return spec->xtype;
}

extern xtagType nextSiblingXtag (xtagType type)
{
	xtagDesc *xdesc;

	xdesc = xtagDescs + type;
	return xdesc->sibling;
}
