/*
 * Generated by ./misc/optlib2c from optlib/qemuhx.ctags, Don't edit this manually.
 */
#include "general.h"
#include "parse.h"
#include "routines.h"
#include "field.h"
#include "xtag.h"
#include "selectors.h"


static void initializeQemuHXParser (const langType language)
{

	addLanguageRegexTable (language, "toplevel");
	addLanguageRegexTable (language, "skiplines");
	addLanguageRegexTable (language, "texi");
	addLanguageRegexTable (language, "rst");
	addLanguageRegexTable (language, "cmd");
	addLanguageRegexTable (language, "cmd0");

	addLanguageTagMultiTableRegex (language, "toplevel",
	                               "^HXCOMM[^\n]*[\n]*",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "toplevel",
	                               "^STEXI[\n]*",
	                               "", "", "{tenter=texi}", NULL);
	addLanguageTagMultiTableRegex (language, "toplevel",
	                               "^SRST[^\n]*[\n]*",
	                               "", "", "{tenter=rst}", NULL);
	addLanguageTagMultiTableRegex (language, "toplevel",
	                               "^[ \t]*DEF\\(\"([^\"\n]+)\"[^\n]*[\n]",
	                               "\\1", "c", "", NULL);
	addLanguageTagMultiTableRegex (language, "toplevel",
	                               "^[ \t]*\\{[ \t]*[\n]+",
	                               "", "", "{tenter=cmd}", NULL);
	addLanguageTagMultiTableRegex (language, "toplevel",
	                               "^[^\n]+[\n]*",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "toplevel",
	                               "^[\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "toplevel",
	                               "^.",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "skiplines",
	                               "^[^\n]+[\n]*",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "skiplines",
	                               "^[\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "skiplines",
	                               "^.",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "texi",
	                               "^ETEXI[\n]*",
	                               "", "", "{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "texi",
	                               "^@item[[:space:]]{1,}([-.a-z_0-9A-Z]{1,})[^\n]*[\n]*",
	                               "\\1", "i", "", NULL);
	addLanguageTagMultiTableRegex (language, "texi",
	                               "^[^\n]+[\n]*",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "texi",
	                               "^[\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "texi",
	                               "^.",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "rst",
	                               "^ERST[^\n]*[\n]*",
	                               "", "", "{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "rst",
	                               "^[^\n]+[\n]*",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "rst",
	                               "^[\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "rst",
	                               "^.",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "cmd",
	                               "^[ \t]*(STEXI)[\n]*",
	                               "", "", "{tleave}{_advanceTo=1start}", NULL);
	addLanguageTagMultiTableRegex (language, "cmd",
	                               "^[ \t]*(SRST)[^\n]*[\n]*",
	                               "", "", "{tleave}{_advanceTo=1start}", NULL);
	addLanguageTagMultiTableRegex (language, "cmd",
	                               "^[ \t]*\\}[ \t]*,[ \t]*[\n]*",
	                               "", "", "{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "cmd",
	                               "^[ \t]*DEF\\(\"([^\"\n]+)\"[^\n]*[\n]",
	                               "\\1", "c", "", NULL);
	addLanguageTagMultiTableRegex (language, "cmd",
	                               "^[ \t]*\\.name[ \t]*=[ \t]*\"",
	                               "", "", "{tenter=cmd0}", NULL);
	addLanguageTagMultiTableRegex (language, "cmd",
	                               "^[^\n]+[\n]*",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "cmd",
	                               "^[\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "cmd",
	                               "^.",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "cmd0",
	                               "^([^|\n]+)\\|",
	                               "\\1", "c", "", NULL);
	addLanguageTagMultiTableRegex (language, "cmd0",
	                               "^([^\"\n]+)\"[^\n]*[\n]",
	                               "\\1", "c", "{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "cmd0",
	                               "^[^\n]+[\n]*",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "cmd0",
	                               "^[\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "cmd0",
	                               "^.",
	                               "", "", "", NULL);
}

extern parserDefinition* QemuHXParser (void)
{
	static const char *const extensions [] = {
		"hx",
		NULL
	};

	static const char *const aliases [] = {
		NULL
	};

	static const char *const patterns [] = {
		NULL
	};

	static kindDefinition QemuHXKindTable [] = {
		{
		  true, 'q', "qmp", "QEMU Management Protocol dispatch table entries",
		},
		{
		  true, 'i', "infoitem", "item in texinfo doc",
		},
		{
		  true, 'c', "commands", "name member in HMPCommand struct",
		  .version = 1,
		},
	};
	static xtagDefinition QemuHXXtagTable [] = {
		{
		  .enabled     = true,
		  .name        = "funcmap",
		  .description = "Include mapping SQMP to C function name",
		},
	};
	static tagRegexTable QemuHXTagRegexTable [] = {
		{"^SQMP[[:space:]]([-a-z_0-9A-Z]+)[[:space:]]---", "\\1",
		"q", "{mgroup=1}", NULL, true},
		{"^SQMP[[:space:]]([-a-z_0-9A-Z]+)[[:space:]]---", "qmp_\\1",
		"q", "{mgroup=1}{_extra=funcmap}"
		"{{\n"
		"    . :name dup (-_) _tr!\n"
		"    . exch name:\n"
		"}}", NULL, true},
	};

	static selectLanguage selectors[] = { selectHaxeOrQemuHXByCommentMarker, NULL };

	parserDefinition* const def = parserNew ("QemuHX");

	def->versionCurrent= 0;
	def->versionAge    = 0;
	def->enabled       = true;
	def->extensions    = extensions;
	def->patterns      = patterns;
	def->aliases       = aliases;
	def->selectLanguage= selectors;
	def->method        = METHOD_NOT_CRAFTED|METHOD_REGEX;
	def->useCork       = CORK_QUEUE;
	def->kindTable     = QemuHXKindTable;
	def->kindCount     = ARRAY_SIZE(QemuHXKindTable);
	def->xtagTable     = QemuHXXtagTable;
	def->xtagCount     = ARRAY_SIZE(QemuHXXtagTable);
	def->tagRegexTable = QemuHXTagRegexTable;
	def->tagRegexCount = ARRAY_SIZE(QemuHXTagRegexTable);
	def->initialize    = initializeQemuHXParser;

	return def;
}
